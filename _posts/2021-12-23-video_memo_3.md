---
title:  "[Android] 동영상에 그림 그리기 (3) - OpenGL ES"
excerpt: "OpenGL ES 렌더링 과정과 Android에서의 사용법"

categories:
  - Android
tags:
  - [Android, OpenGL ES]
 
date: 2021-12-23
last_modified_at: 2021-12-23
---

# OpenGL ES

그림을 그리기 위해서는, 어떻게 그림이 그려지는지 알 필요가 있습니다. 저도 이 과정에 대해 감히 모든 것을 알고 정리한다고 말씀드릴 수는 없을 것입니다. 제가 이 앱을 만들기 위해서 공부했던 범위에서 정리하도록 하겠습니다.

## 렌더링 파이프라인

OpenGL ES 3.0의 전체 렌더링 파이프라인은 [크로노스 그룹 웹페이지](https://www.khronos.org/news/permalink/opengl-es-3.0-pipeline-map)에서 링크를 통해 찾아볼 수 있습니다. 저는 OpenGL ES를 사용하면서 아래 그림과 같이 간단하게 정리하여 생각하였습니다.

![pipeline](/assets/img/video_memo_3/pipeline.png)

이 중에서 사각형 상자 내의 `Vertex Processing` 과 `Fragment Processing` 과정에서 Shading 이라는 부분을 직접 프로그래밍이 가능합니다. Vertex Shader에서는 점의 위치를 결정하고, Fragment Shader에서는 색상을 결정합니다. 다만 코틀린이 아닌 `GLSL` 이라는 별도의 언어를 사용해야 합니다.

물론 프로그래밍이 가능하지 않다는 것이 어떠한 조작도 불가능하다는 의미는 아닙니다. 제공되는 함수를 통해 기능을 조작이 가능하지만, GLSL 등의 별도의 프로그래밍 언어를 사용하지 않는다는 것이고, 조작의 범위또한 제한적입니다.

# EGL

SurfaceTexture는 이미지 스트림 생성자에서 받은 이미지를 Texture로 사용하여 새로운 이미지를 그려내야 합니다. 그렇다면 어디에 그려야 할까요? [이 앱](https://crewdaniel.github.io/posts/video_memo_1/#%EC%A0%95%EB%A6%AC)에서는 화면을 보여주기 위한 SurfaceView와, 동영상을 저장하기 위한 MediaCodec 두 가지가 필요합니다. OpenGL ES로 렌더링한 결과물은 어디에 그려지는지와, OpenGL ES로 렌더링을 하기 전 초기화 과정에 대해 알기 위해서는 EGL에 대한 이해가 필요합니다.

EGL은 크로노스 그룹의 API들과 여러 플랫폼의 호환을 위해 만들어졌습니다. OpenGL ES 뿐만이 아니라 OpenGL, OpenVG를 사용할 때도 쓰이며, 이러한 라이브러리들이 Android 외에도 다양한 OS와 프로그램에 쓰이기 때문에 이 둘을 이어주는 인터페이스가 필요했기 때문입니다.

EGL의 초기화 단계를 차례대로 살펴보겠습니다. 첫 번째 단계는 EGLDisplay 설정입니다.

```kotlin
private fun getEglDisplay() {
    eglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY)
    if (eglDisplay === EGL14.EGL_NO_DISPLAY) throw Exception("EGLDisplay 가져오기 실패")
}
```

[EGL14](https://developer.android.com/reference/android/opengl/EGL14)는 EGL 1.4를 의미합니다. EGL 1.5가 Android 10(API 29)부터 지원되지만 미만의 버전에서 호환성이 우려되어 API 17에 추가된 EGL 1.4를 사용하였습니다.

`eglGetDisplay(displayId: Int)` 함수를 통해 연결할 디스플레이를 지정하고, 하드웨어 사양을 가져옵니다. `EGL14.EGL_DEFAULT_DISPLAY`로 지정하면 OS에서 지정한 기본값을 넣어주게 됩니다.

```kotlin
private fun eglInit() {
    val version = IntArray(2)
    if (!EGL14.eglInitialize(eglDisplay, version, 0, version, 0)) throw Exception("EGL 초기화 실패")
}
```

다음으로는 `eglInitialize(dpy: EGLDisplay, major: IntArray, majorOffset: Int, minor: IntArray, minorOffset: Int)` 함수를 사용하여 EGL을 초기화합니다. 파라미터가 많아서 어렵게 느껴질 수도 있지만 이미 여기서 중요한 것은 `eglDisplay` 하나입니다. 위에서 선언한 eglDisplay 값을 그대로 넣어주면 됩니다. `version`은 함수 실행 결과 후 version에 EGL 버전 값이 들어가게 됩니다. 하지만 이후에도 EGL 1.4를 사용할 것이기 때문에 이후에 version을 사용하지는 않을 것입니다. 실행 결과는 Boolean 값으로 반환되며 false 반환시 초기화 실패입니다.

```kotlin
private fun eglBind() {
    if (!EGL14.eglBindAPI(EGL14.EGL_OPENGL_ES_API)) throw Exception("EGL 렌더링 API 설정 실패")
}
```

이후 `eglBindAPI(api: Int)` 함수에서 OpenGL ES를 사용할 것을 위 코드와 같이 명시합니다.

(작성중)

# 정리

![videomemo](/assets/img/video_memo_1/videomemo.png)

다시 이 그림을 살펴보면, SurfaceTexture에서 OpenGL ES로 렌더링한 결과는 EGLWindowSurface에 그려집니다. 그렇다면 이 것을 어떻게 SurfaceView와 MediaCodec에 전달할 수 있을까요? 그 방법에 대해서 OpenGL ES의 버전에 따른 방법의 차이와 각 방법을 실행한 결과를 비교해보는 글을 다음 포스트에 이어서 작성하겠습니다.

