---
title:  "[Android] 동영상에 그림 그리기 (8) - BufferQueue"
excerpt: "Android의 그래픽 버퍼 전달"

categories: [Android, boomerang]

tags:
  - [Android, BufferQueue, Window]
 
date: 2022-01-12 02:12:00 +0900
last_modified_at: 2022-01-12 02:12:00 +0900
---

저는 이전 포스트들에서 `SurfaceTexture`, `Surface`, `MediaCodec` 등 미디어, 그래픽 관련 앱을 제외하고는 잘 쓰이지 않는 API들에 대해 다루었습니다. 이러한 API들의 역할과 사용 방법에 대해서는 다루었지만, 조금 더 깊이 알아보고 싶어서 Google I/O '18의 [Drawn out: How Android renders](https://www.youtube.com/watch?v=zdQRIYOST64) 라는 주제의 발표와 공식 문서의 내용들을 조합하여 정리하려 합니다.

# BufferQueue

`BufferQueue`는 이름 그대로 (그래픽) 버퍼의 큐입니다. 중요한 부분은 **`BufferQueue`는 두 개의 엔드포인트를 가지는데, 생산자와 소비자라고 합니다.**

생산자는 `dequeueBuffer()`를 호출하여 `BufferQueue`에서 버퍼를 가져와 소유권을 얻습니다. 그 후 **생산자** 라는 이름에 맞게 내용을 채워넣을 수 있습니다. 그게 `Canvas`가 될 수도 있고, `OpenGL ES`가 될 수도 있으며, 픽셀 데이터를 직접 넣을 수도 있습니다.

생산자가 버퍼에 데이터를 모두 넣은 후에는, 다시 `BufferQueue`에 버퍼를 `queueBuffer()` 호출로 돌려줍니다. `SurfaceTexture` 클래스에서 OpenGL ES 렌더링이 끝난 후 `eglSwapBuffers()`를 호출하는 것도 이 `queueBuffer()` 과정에 해당합니다.

생산자의 역할은 끝났으니, 이제는 소비자 차례입니다. 소비자는 `acquireBuffer()`를 호출하여 `BufferQueue`에서 버퍼를 가져옵니다. 소비자는 가져온 버퍼로 원하는 작업을 수행하고(지난 포스트의 `MediaCodec`을 예로 들자면, 버퍼를 가져와서 MediaMuxer에 작성하였습니다.) `releaseBuffer()`로 다시 `BufferQueue`에 버퍼를 돌려줍니다.

이렇게 생산자와 소비자가 그래픽 버퍼를 `BufferQueue`를 통해 교환할 수 있기 때문에, 생산자와 소비자가 다른 성격의 API이더라도 그래픽 데이터를 전달할 수 있습니다. 따라서 이 앱에서 동영상을 재생하는 `MediaPlayer`로부터 OpenGL ES를 사용하는 `SurfaceTexture`에 프레임 단위로 동영상을 전달하는 것이 가능했던 것이죠.

<!-- 그리고 이것이 Android의 Surface Compositor가 작동하는 방식입니다. -->

`Surface`는 `BufferQueue`의 생산자쪽 엔드포인트에 해당합니다. 이 엔드포인트의 반대편, 즉 소비자는 주로 `SurfaceFlinger`로, `Window`들을 모아 화면을 구성하는 역할을 합니다. 하지만 제가 이전 포스트들에서 다룬 `SurfaceTexture`, `MediaCodec` API 또한 소비자로 작동했습니다. `SurfaceFlinger`를 소비자로 사용하게 되는 방법 중 하나는 `SurfaceView` API를 사용하는 것인데, 이는 다음 포스트에서 그림이 그려진 동영상을 재생하는 내용을 다루면서 작성하도록 하겠습니다.
