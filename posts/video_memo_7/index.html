<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩" /><meta property="og:locale" content="ko" /><meta name="description" content="MediaCodec을 사용한 동영상 인코딩 과정" /><meta property="og:description" content="MediaCodec을 사용한 동영상 인코딩 과정" /><link rel="canonical" href="https://crewdaniel.github.io/posts/video_memo_7/" /><meta property="og:url" content="https://crewdaniel.github.io/posts/video_memo_7/" /><meta property="og:site_name" content="Devroid" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-05T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"MediaCodec을 사용한 동영상 인코딩 과정","url":"https://crewdaniel.github.io/posts/video_memo_7/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://crewdaniel.github.io/posts/video_memo_7/"},"headline":"[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩","dateModified":"2022-01-05T00:00:00+09:00","datePublished":"2022-01-05T00:00:00+09:00","@context":"https://schema.org"}</script><title>[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩 | Devroid</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Devroid"><meta name="application-name" content="Devroid"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Devroid</a></div><div class="site-subtitle">안드로이드 개발 일지</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/CrewDaniel" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['alaskay','naver.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Taehyun Park </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 5, 2022, 12:00 AM +0900" >Jan 5<i class="unloaded">2022-01-05T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 5, 2022, 12:00 AM +0000" >Jan 5<i class="unloaded">2022-01-05T00:00:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2267 words">12 min read</span></div></div><div class="post-content"><p>이번 포스트에서는 MediaCodec과 MediaMuxer를 사용하여 렌더링된 그래픽들을 동영상으로 합성하는 내용에 대해 작성하도록 하겠습니다.</p><h1 id="mediacodec">MediaCodec</h1><p><a href="https://developer.android.com/reference/android/media/MediaCodec">MediaCodec</a>은 인코딩, 디코딩 기능을 하는 클래스입니다.</p><p>MediaCodec 클래스에서 사용하는 데이터는 <a href="https://developer.android.com/reference/java/nio/ByteBuffer">ByteBuffer</a>로도 가능하지만, 비디오 데이터는 지난 포스트들에서 그래픽 버퍼 전달에 쓰여왔던 <code class="language-plaintext highlighter-rouge">Surface</code>를 사용하는 것이 코덱 성능에 이롭습니다. 지난 포스트들에서 겪었던 과정들을 돌아보면 Surface 클래스를 사용하면서 그래픽 버퍼를 이동시키기 위해 복사를 하거나 매핑하는 과정을 거칠 필요가 없었기 때문에 효율적이라고 할 수 있습니다.</p><p>또한 Surface를 사용하는 것이 구현에 있어서도 더 편합니다. MediaCodec의 입력으로 Surface를 사용하면, 자동으로 버퍼를 코덱에 연결하기 때문에 입력 버퍼와 관련된 함수를 사용할 필요가 없을 뿐만 아니라, <strong>색 영역에 대한 포맷 설정이 매우 간단해집니다.</strong></p><p>H.264(AVC) 포맷으로 인코딩시에는 YUV420 값이 필요하고, 이 포맷은 기기의 색상값에 따라 다르기 때문에 확인을 해야 하는 등 복잡한 과정이 필요합니다. 하지만 Surface를 사용한다면, 아래와 같이 색 영역 포맷 설정을 끝낼 수 있습니다.</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">format</span><span class="p">.</span><span class="nf">setInteger</span><span class="p">(</span>
    <span class="nc">MediaFormat</span><span class="p">.</span><span class="nc">KEY_COLOR_FORMAT</span><span class="p">,</span>
    <span class="nc">MediaCodecInfo</span><span class="p">.</span><span class="nc">CodecCapabilities</span><span class="p">.</span><span class="nc">COLOR_FormatSurface</span>
<span class="p">)</span>
</pre></table></code></div></div><p>Surface로 전달받는 비디오 버퍼의 색 영역 포맷을 그대로 사용할 수 있습니다. 그렇다면 색 영역 포맷은 어디서 설정했을까요? <a href="https://crewdaniel.github.io/posts/video_memo_3/#eglconfig">이전 포스트에서</a> <code class="language-plaintext highlighter-rouge">EGLConfig</code>를 설정할 때 <code class="language-plaintext highlighter-rouge">RGBA_8888</code> 로 설정했습니다. 이 값이 그대로 적용될 것입니다.</p><p>또한 Surface 사용시 동영상이 끝나는 지점을 <a href="https://developer.android.com/reference/android/media/MediaCodec#signalEndOfInputStream()">signalEndOfInputStream()</a> 함수로 알 수 있기 때문에 종료 시점을 아는 것에 있어 유용합니다.</p><p>정리하자면, Surface 클래스를 사용하는 것이 ByteBuffer를 사용하는 것 보다 인코딩/디코딩에 있어 편리합니다.</p><p>MediaCodec 클래스는 <a href="https://developer.android.com/reference/android/media/MediaCodec#createInputSurface()">createInputSurface()</a> 함수로 Surface 인스턴스를 생성하여 인코더의 입력으로 사용할 수 있습니다. 이는 <a href="https://crewdaniel.github.io/posts/video_memo_2/">지난 포스트에서</a> SurfaceTexture가 생성한 Surface 인스턴스를 MediaPlayer에게 주어 동영상의 이미지 버퍼를 받던 것과 같은 방식이라고 생각할 수 있습니다.</p><p>하지만 <code class="language-plaintext highlighter-rouge">createInputSurface()</code> 전에 인코더의 포맷을 설정해야 합니다.</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">val</span> <span class="py">encoder</span> <span class="p">=</span> <span class="nc">MediaCodec</span><span class="p">.</span><span class="nf">createEncoderByType</span><span class="p">(</span><span class="s">"video/avc"</span><span class="p">)</span>
</pre></table></code></div></div><p>우선 인코더를 희망하는 MIME 타입에 맞게 생성하고, 포맷 설정을 살펴보도록 하겠습니다.</p><h2 id="mediaformat">MediaFormat</h2><p>필수적으로 설정하여야 하는 포맷은 <a href="https://developer.android.com/reference/android/media/MediaFormat">MediaFormat</a> 레퍼런스 페이지를 참조하면 됩니다.</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">val</span> <span class="py">format</span> <span class="p">=</span> <span class="nc">MediaFormat</span><span class="p">.</span><span class="nf">createVideoFormat</span><span class="p">(</span><span class="s">"video/avc"</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
</pre></table></code></div></div><p>우선 최소한의 설정을 담은 비디오 포맷을 생성합니다. MIME, 너비, 높이 값(픽셀 단위)이 파라미터로 필요합니다. 이후부터는 <code class="language-plaintext highlighter-rouge">format.setInteger(...)</code>로 포맷을 더해가면 됩니다.</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">format</span><span class="p">.</span><span class="nf">setInteger</span><span class="p">(</span>
    <span class="nc">MediaFormat</span><span class="p">.</span><span class="nc">KEY_COLOR_FORMAT</span><span class="p">,</span>
    <span class="nc">MediaCodecInfo</span><span class="p">.</span><span class="nc">CodecCapabilities</span><span class="p">.</span><span class="nc">COLOR_FormatSurface</span>
<span class="p">)</span>
<span class="n">format</span><span class="p">.</span><span class="nf">setInteger</span><span class="p">(</span><span class="nc">MediaFormat</span><span class="p">.</span><span class="nc">KEY_BIT_RATE</span><span class="p">,</span> <span class="n">bitrate</span><span class="p">)</span>
<span class="n">format</span><span class="p">.</span><span class="nf">setInteger</span><span class="p">(</span><span class="nc">MediaFormat</span><span class="p">.</span><span class="nc">KEY_FRAME_RATE</span><span class="p">,</span> <span class="n">frameRate</span><span class="p">)</span>
<span class="n">format</span><span class="p">.</span><span class="nf">setInteger</span><span class="p">(</span><span class="nc">MediaFormat</span><span class="p">.</span><span class="nc">KEY_I_FRAME_INTERVAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">KEY_COLOR_FORMAT</code>은 위에서 작성한대로 Surface의 포맷을 따르도록 하였습니다.</p><p><code class="language-plaintext highlighter-rouge">KEY_BIT_RATE</code>는 비트레이트 값을 설정합니다. 안드로이드에서 H.264(AVC) 인코딩 시에 권장하는 스펙은 <a href="https://developer.android.com/guide/topics/media/media-formats?hl=ko#video-encoding">공식 문서</a> 에서 확인할 수 있습니다.</p><p><code class="language-plaintext highlighter-rouge">KEY_FRAME_RATE</code>는 목표로 하는 초당 프레임 수를 설정합니다. 하지만 실제 값은 <code class="language-plaintext highlighter-rouge">timestamp</code>에 의해 각 프레임이 자리하는 시간이 바뀌기 때문에, 여기서 설정한 FPS 값대로 동영상이 출력된다는 보장은 없습니다.</p><p><code class="language-plaintext highlighter-rouge">KEY_I_FRAME_INTERVAL</code>은 Intra Frame이 몇 초에 하나씩 위치할 것인지를 설정합니다. 인코딩 시에는 모든 프레임이 완전한 그림의 형태를 가지지 않고, 이러한 Intra Frame와의 변화값만을 가져 크기를 압축합니다. 하지만 Intra Frame이 너무 적다면, 영상을 재생하다가 다른 부분을 보고 싶어서 중간으로 이동할 때, 해당 프레임을 알기 위해서 Intra Frame을 찾을 때 목표 위치와 크게 떨어질 수 있고, 그 결과 재생에 오랜 시간이 걸리게 될 것입니다. 따라서 적절한 값을 설정하여야 합니다.</p><p><code class="language-plaintext highlighter-rouge">KEY_I_FRAME_INTERVAL</code> 값을 음수로 설정하면 첫 번째 프레임을 제외한 어떠한 Intra Frame도 설정하지 않으며, 값을 0으로 설정시에는 모든 프레임이 Intra Frame이 됩니다.</p><p>포맷 설정을 마치고 나면, 이제 <code class="language-plaintext highlighter-rouge">createInputSurface()</code>로 Surface 인스턴스를 생성할 수 있을 것입니다.</p><h2 id="mediacodec-설정">MediaCodec 설정</h2><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">encoder</span><span class="p">.</span><span class="nf">configure</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="nc">MediaCodec</span><span class="p">.</span><span class="nc">CONFIGURE_FLAG_ENCODE</span><span class="p">)</span>
<span class="n">inputSurface</span> <span class="p">=</span> <span class="n">encoder</span><span class="p">.</span><span class="nf">createInputSurface</span><span class="p">()</span>
<span class="n">encoder</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</pre></table></code></div></div><p><a href="https://developer.android.com/reference/android/media/MediaCodec#createInputSurface()">createInputSurface()</a>는 레퍼런스 문서에서 확인할 수 있듯이, <code class="language-plaintext highlighter-rouge">configure(...)</code> 이후, <code class="language-plaintext highlighter-rouge">start()</code> 이전에 위치하여야 합니다.</p><p><a href="https://developer.android.com/reference/android/media/MediaCodec#configure(android.media.MediaFormat,%20android.view.Surface,%20android.media.MediaCrypto,%20int)">configure(…)</a>는 <code class="language-plaintext highlighter-rouge">MediaFormat</code>, <code class="language-plaintext highlighter-rouge">Surface</code>, <code class="language-plaintext highlighter-rouge">MediaCrypto</code>, <code class="language-plaintext highlighter-rouge">flags: Int</code> 를 필요로 합니다. MediaFormat은 위에서 설정한 포맷이 그대로 들어가면 되고, Surface와 MediaCrypto는 인코더에서는 사용하지 않으므로 null, 인코더로 사용을 알리는 flag인 <code class="language-plaintext highlighter-rouge">CONFIGURE_FLAG_ENCODE</code>을 각각 인자로 넣었습니다.</p><p>모든 설정이 끝난 후, <code class="language-plaintext highlighter-rouge">start()</code> 함수를 호출하면 됩니다.</p><h2 id="인코딩">인코딩</h2><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">val</span> <span class="py">bufferInfo</span> <span class="p">=</span> <span class="nc">MediaCodec</span><span class="p">.</span><span class="nc">BufferInfo</span><span class="p">()</span>

<span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(</span><span class="kd">val</span> <span class="py">encoderStatus</span> <span class="p">=</span> <span class="n">encoder</span><span class="p">.</span><span class="nf">dequeueOutputBuffer</span><span class="p">(</span><span class="n">bufferInfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="nc">MediaCodec</span><span class="p">.</span><span class="nc">INFO_TRY_AGAIN_LATER</span> <span class="p">-&gt;</span> <span class="k">break</span>
        <span class="nc">MediaCodec</span><span class="p">.</span><span class="nc">INFO_OUTPUT_FORMAT_CHANGED</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">encodedFormat</span> <span class="p">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">outputFormat</span>
            <span class="n">videoTrack</span> <span class="p">=</span> <span class="n">mediaMuxer</span><span class="p">.</span><span class="nf">addTrack</span><span class="p">(</span><span class="n">encodedFormat</span><span class="p">)</span>
            <span class="n">mediaMuxer</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
            <span class="n">isMuxerStart</span> <span class="p">=</span> <span class="k">true</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="kd">val</span> <span class="py">encoderOutputBuffers</span> <span class="p">=</span> <span class="n">encoder</span><span class="p">.</span><span class="nf">getOutputBuffer</span><span class="p">(</span><span class="n">encoderStatus</span><span class="p">)</span>
                <span class="o">?:</span> <span class="k">throw</span> <span class="nc">Exception</span><span class="p">(</span><span class="s">"MediaCodec.getOutputBuffer is null"</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bufferInfo</span><span class="p">.</span><span class="n">flags</span> <span class="n">and</span> <span class="nc">MediaCodec</span><span class="p">.</span><span class="nc">BUFFER_FLAG_CODEC_CONFIG</span> <span class="p">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">bufferInfo</span><span class="p">.</span><span class="n">size</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bufferInfo</span><span class="p">.</span><span class="n">size</span> <span class="p">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">isMuxerStart</span><span class="p">)</span> <span class="n">mediaMuxer</span><span class="p">.</span><span class="nf">writeSampleData</span><span class="p">(</span>
                    <span class="n">videoTrack</span><span class="p">,</span>
                    <span class="n">encoderOutputBuffers</span><span class="p">,</span>
                    <span class="n">bufferInfo</span>
                <span class="p">)</span>
            <span class="p">}</span>
            <span class="n">encoder</span><span class="p">.</span><span class="nf">releaseOutputBuffer</span><span class="p">(</span><span class="n">encoderStatus</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bufferInfo</span><span class="p">.</span><span class="n">flags</span> <span class="n">and</span> <span class="nc">MediaCodec</span><span class="p">.</span><span class="nc">BUFFER_FLAG_END_OF_STREAM</span> <span class="p">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><a href="https://developer.android.com/reference/android/media/MediaCodec#dequeueOutputBuffer(android.media.MediaCodec.BufferInfo,%20long)">dequeueOutputBuffer</a>는 출력 버퍼의 인덱스를 반환합니다. 두 개의 파라미터가 필요한데, 첫 번째는 <a href="https://developer.android.com/reference/android/media/MediaCodec.BufferInfo">MediaCodec.BufferInfo</a>로, 버퍼의 메타데이터가 채워지게 됩니다. 두 번째로는 타임아웃입니다. 타임아웃 값을 0으로 설정하였는데 이 경우 버퍼를 확인하고 없으면 기다리지 않고 바로 <code class="language-plaintext highlighter-rouge">INFO_TRY_AGAIN_LATER</code> 값을 반환합니다.</p><p>이 과정이 성공적으로 끝났다면 이후로는 <a href="https://developer.android.com/reference/android/media/MediaCodec#getOutputBuffer(int)">getOutputBuffer</a>로 출력 버퍼의 데이터를 <code class="language-plaintext highlighter-rouge">ByteBuffer</code>로 가져옵니다. 이제 <code class="language-plaintext highlighter-rouge">dequeueOutputBuffer(...)</code>에서 가져온 <code class="language-plaintext highlighter-rouge">BufferInfo</code>의 메타데이터를 확인하여 유효한 값인지 확인하여야 합니다.</p><p>우선 <code class="language-plaintext highlighter-rouge">bufferInfo.flags</code> 와 <code class="language-plaintext highlighter-rouge">MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 2</code>의 비트연산입니다. 비트연산에서 0이 나오지 않으면 size를 0으로 만들어 다음에서 MediaMuxer에 버퍼를 넘기지 않도록 구현이 되어있습니다. 다른 일반적인 flags는 2와의 비트연산 결과에서 0이 나올 수 있도록 값을 가지고 있습니다. <code class="language-plaintext highlighter-rouge">MediaCodec.INFO_TRY_AGAIN_LATER == -1</code>과 <code class="language-plaintext highlighter-rouge">MediaCodec.INFO_OUTPUT_FORMAT_CHANGED == -2</code> 둘은 연산결과에서 0이 아닌 값을 가지게 되는데, <code class="language-plaintext highlighter-rouge">dequeueOutputBuffer</code>의 반환값을 구분했던 것과 같습니다.</p><p>다음으로 MediaMuxer에 출력 버퍼의 데이터를 전달하고, 출력 버퍼를 release 합니다. 이 작업을 매 프레임마다 반복합니다.</p><h1 id="mediamuxer">MediaMuxer</h1><p>MediaCodec의 결과물이 바로 .MP4 등의 파일로 출력되는 것은 아닙니다. 포맷에 맞게 인코딩은 완료되었지만, 이제 파일로 만드는 부분을 <a href="https://developer.android.com/reference/android/media/MediaMuxer">MediaMuxer</a>가 담당하게 됩니다.</p><p>인코딩 데이터는 <a href="https://developer.android.com/reference/android/media/MediaMuxer#writeSampleData(int,%20java.nio.ByteBuffer,%20android.media.MediaCodec.BufferInfo)">writeSampleData</a> 함수에 <code class="language-plaintext highlighter-rouge">ByteBuffer</code> 데이터와 <code class="language-plaintext highlighter-rouge">MediaCodec.BufferInfo</code> 메타데이터를 파라미터로 전달하게 됩니다.</p><h1 id="종료">종료</h1><p>인코딩을 마치고 나면, MediaCodec과 MediaMuxer 각각을 종료해야 합니다.</p><p><code class="language-plaintext highlighter-rouge">MediaCodec</code>에서의 <a href="https://developer.android.com/reference/android/media/MediaCodec#stop()">stop</a>은 인코딩/디코딩 후 호출하면 됩니다. <code class="language-plaintext highlighter-rouge">stop()</code> 호출 뒤에도 다시 <code class="language-plaintext highlighter-rouge">start()</code> 함수를 호출하여 다시 시작할 수 있습니다.</p><p><code class="language-plaintext highlighter-rouge">MediaCodec</code>에서 사용하였던 모든 리소스들을 정리하려면 <a href="https://developer.android.com/reference/android/media/MediaCodec#release()">release</a>를 호출하여야 합니다. 인코딩/디코딩 작업이 끝났을 때 메모리 정리를 가비지 컬렉터에 의존하지 말고, 직접 <code class="language-plaintext highlighter-rouge">release()</code> 함수를 호출하여야 한다고 공식 문서에 명시되어 있습니다.</p><p><code class="language-plaintext highlighter-rouge">MediaMuxer</code>에서의 <a href="https://developer.android.com/reference/android/media/MediaMuxer#stop()">stop</a>은 약간 다릅니다. 호출 후에는 다시 시작될 수 없습니다.</p><p><code class="language-plaintext highlighter-rouge">MediaMuxer</code>에서의 <a href="https://developer.android.com/reference/android/media/MediaMuxer#release()">release</a>는 <code class="language-plaintext highlighter-rouge">MediaCodec</code>의 <code class="language-plaintext highlighter-rouge">release</code>처럼 사용한 리소스들을 정리합니다.</p><p>두 클래스의 인스턴스에 대하여 각각 <code class="language-plaintext highlighter-rouge">stop()</code>, <code class="language-plaintext highlighter-rouge">release()</code> 순서로 호출하면 됩니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>Android</a>, <a href='/categories/boomerang/'>boomerang</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >Android</a> <a href="/tags/mediacodec/" class="post-tag no-text-decoration" >MediaCodec</a> <a href="/tags/mediamuxer/" class="post-tag no-text-decoration" >MediaMuxer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩 - Devroid&url=https://crewdaniel.github.io/posts/video_memo_7/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩 - Devroid&u=https://crewdaniel.github.io/posts/video_memo_7/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩 - Devroid&url=https://crewdaniel.github.io/posts/video_memo_7/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cs_3/">[CS] 비동기 프로그래밍 (3) - 동시성 프로그래밍</a><li><a href="/posts/cs_2/">[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크</a><li><a href="/posts/cs_1/">[CS] 비동기 프로그래밍 (1) - 캐시 메모리</a><li><a href="/posts/video_memo_10/">[Android] 동영상에 그림 그리기 (10) - 개선 리스트</a><li><a href="/posts/video_memo_8/">[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/opengl-es/">OpenGL ES</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/surface/">Surface</a> <a class="post-tag" href="/tags/egl/">EGL</a> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/surfacetexture/">SurfaceTexture</a> <a class="post-tag" href="/tags/async/">Async</a> <a class="post-tag" href="/tags/asynchronous/">Asynchronous</a> <a class="post-tag" href="/tags/boostcamp/">boostcamp</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/video_memo_4/"><div class="card-body"> <span class="timeago small" >Dec 31, 2021<i class="unloaded">2021-12-31T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (4) - OpenGL ES의 Texture</h3><div class="text-muted small"><p> 이제 그림을 그릴 시간입니다. Android에서 OpenGL ES 렌더링 과정, 특히 SurfaceTexture를 사용하여 이미지를 텍스처로 사용하는 과정에 대해 정리하겠습니다. SurfaceTexture Texture 초기화 지난 글에서 onFrameAvailableListener를 통해 새로운 이미지 프레임을 받은 것을 알 수 있다고 하였습니...</p></div></div></a></div><div class="card"> <a href="/posts/video_memo_5/"><div class="card-body"> <span class="timeago small" >Jan 1<i class="unloaded">2022-01-01T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (5) - OpenGL ES의 Shader, 그림 그리기</h3><div class="text-muted small"><p> 렌더링을 위해서는 Shader가 필요합니다. 이번 포스트에서는 Shader에 대해 작성하도록 하겠습니다. Shader 렌더링 파이프라인에서 Vertex Shader와 Fragment Shader는 필수적으로 사용자가 직접 구현해야 하는 부분입니다. GLSL이라는 언어를 사용하여 구현하여야 합니다. Vertex Shader 입력되는 점마다 하나씩...</p></div></div></a></div><div class="card"> <a href="/posts/video_memo_6/"><div class="card-body"> <span class="timeago small" >Jan 2<i class="unloaded">2022-01-02T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (6) - Framebuffer 전달 및 복사</h3><div class="text-muted small"><p> OpenGL ES의 렌더링 과정을 모두 마치면, EGLSurface에 Framebuffer가 들어가게 됩니다. 그런데 이 앱에서 Framebuffer가 필요한 Surface는 두 곳이 있습니다. 하나는 화면에 표시하기 위한 SurfaceView이고, 다른 하나는 동영상 저장을 위한 MediaCodec 입니다. 이 과정에서 제가 구현한 방법과 각 방법에...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/video_memo_6/" class="btn btn-outline-primary" prompt="Older"><p>[Android] 동영상에 그림 그리기 (6) - Framebuffer 전달 및 복사</p></a> <a href="/posts/video_memo_8/" class="btn btn-outline-primary" prompt="Newer"><p>[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/CrewDaniel">Taehyun Park</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/opengl-es/">OpenGL ES</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/surface/">Surface</a> <a class="post-tag" href="/tags/egl/">EGL</a> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/surfacetexture/">SurfaceTexture</a> <a class="post-tag" href="/tags/async/">Async</a> <a class="post-tag" href="/tags/asynchronous/">Asynchronous</a> <a class="post-tag" href="/tags/boostcamp/">boostcamp</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
