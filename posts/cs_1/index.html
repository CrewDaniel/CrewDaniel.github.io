<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[CS] 비동기 프로그래밍 (1) - 캐시 메모리" /><meta property="og:locale" content="ko" /><meta name="description" content="비동기 프로그래밍과 안드로이드에서의 사용" /><meta property="og:description" content="비동기 프로그래밍과 안드로이드에서의 사용" /><link rel="canonical" href="https://crewdaniel.github.io/posts/cs_1/" /><meta property="og:url" content="https://crewdaniel.github.io/posts/cs_1/" /><meta property="og:site_name" content="Devroid" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-19T23:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[CS] 비동기 프로그래밍 (1) - 캐시 메모리" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"비동기 프로그래밍과 안드로이드에서의 사용","url":"https://crewdaniel.github.io/posts/cs_1/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://crewdaniel.github.io/posts/cs_1/"},"headline":"[CS] 비동기 프로그래밍 (1) - 캐시 메모리","dateModified":"2022-02-26T01:00:00+09:00","datePublished":"2022-02-19T23:00:00+09:00","@context":"https://schema.org"}</script><title>[CS] 비동기 프로그래밍 (1) - 캐시 메모리 | Devroid</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Devroid"><meta name="application-name" content="Devroid"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Devroid</a></div><div class="site-subtitle">안드로이드 개발 일지</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/CrewDaniel" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['alaskay','naver.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[CS] 비동기 프로그래밍 (1) - 캐시 메모리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[CS] 비동기 프로그래밍 (1) - 캐시 메모리</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Taehyun Park </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Feb 19, 2022, 11:00 PM +0900" >Feb 19<i class="unloaded">2022-02-19T23:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Feb 26, 2022, 1:00 AM +0900" >Feb 26<i class="unloaded">2022-02-26T01:00:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3384 words">18 min read</span></div></div><div class="post-content"><p>비동기 프로그래밍에 대해 공부를 하다보니 굉장히 멀리 오게 되었고, 그래서 하나씩 정리를 하려고 합니다. bottom-up 방식으로 작성하여 첫 게시글인 캐시 메모리에서부터 가장 고단위인 코루틴까지 작성할 예정입니다.</p><h1 id="캐시-메모리">캐시 메모리</h1><p>캐시 메모리에 대해 모든 내용을 작성하기 보다는, 비동기 프로그래밍을 이해하는 것에 필요한 내용 위주로 정리하였습니다.</p><h2 id="데이터-지역성">데이터 지역성</h2><p>캐시 메모리는 데이터의 지역성을 이용하여 처리 속도를 높입니다. 캐시 메모리가 가져오는 데이터는 프로세서에서 자주 쓰이는 데이터여야 합니다. 한 번만 쓰고 다시 다른 데이터를 불러온다면, 그냥 저장소에서 바로 가져오는 것이 여러 중간단계를 거치는 것보다 더 빠를 것입니다. 캐시 메모리에 쓰이는 데이터는 프로세서에서 자주 접근하는 데이터로 구성해야 이득을 얻을 수 있을텐데, 그 데이터를 어떻게 알 수 있을까요?</p><p>자주 사용하는 데이터는 <code class="language-plaintext highlighter-rouge">데이터 지역성</code>의 원리를 따릅니다. 시간 지역성과 공간 지역성으로 나누어서 볼 수 있습니다.</p><p>시간 지역성은 최근 접근한 데이터에 다시 접근할 확률이 높다는 것을 의미합니다. 예를 들어 반복문에서 같은 변수에 여러 번 접근하는 경우가 있습니다.</p><p>공간 지역성은 최근 접근한 데이터의 주변 데이터에 다시 접근할 확률이 높다는 것을 의미합니다. 배열은 연속적으로 할당되기에, 특정 배열의 데이터들을 접근한다면 공간적으로 연속된 데이터들에 접근하는 것을 의미합니다.</p><div class="language-kotlin highlighter-rouge"><div class="code-header"> <span text-data=" Kotlin "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span> <span class="p">{</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">i</span><span class="p">}</span>
</pre></table></code></div></div><p>위의 반복문에서 변수 i가 호출되는 것은 시간 지역성을 의미하며, arr[i]에서 배열의 원소를 연속적으로 호출하는 것은 공간 지역성을 의미합니다.</p><h2 id="캐시-메모리의-구조">캐시 메모리의 구조</h2><p><img data-proofer-ignore data-src="/assets/img/cs_1/cpu.png" alt="cpu" /></p><p>프로세서마다 차이가 있지만, 많은 프로세서에서 각 코어마다 L1 캐시와 L2 캐시를 가지고, 모든 코어가 공유하는 L3 캐시를 둡니다. 위 자료의 오른쪽 하단에서 L1과 L2에는 앞에 4X라고 표시된 것이 4개가 장착되었다는 것으로 4코어 프로세서인 i7-8650U의 각 코어에 할당된 것입니다. 그리고 L3 캐시는 별다른 표시가 없으므로 하나만 존재한다는 것을 알 수 있습니다.</p><p><img data-proofer-ignore data-src="/assets/img/cs_1/cache.png" alt="cache" /></p><p><code class="language-plaintext highlighter-rouge">8-way set associative, 64-byte line size</code>는 캐시 라인의 크기와, 캐시 매핑 정책에 대한 것입니다.</p><p>프로세서가 한 사이클에 처리할 수 있는 단위인 워드 몇 개를 묶어 하나의 캐시 라인(캐시 블록)이라고 합니다. <code class="language-plaintext highlighter-rouge">line size</code>는 캐시 라인의 크기를 의미하며, 64byte는 64bit의 워드 8개가 묶인 것으로 이해할 수 있습니다. 캐시의 데이터를 교체할 때는 특정 워드 하나만 교체할 수 없으며, 캐시 라인 전체를 교체해야 합니다. 그 이유는 캐시 데이터 교체에는 비용이 드는데, 공간 지역성을 생각하면 인접한 데이터들도 사용될 확률이 높기 때문에 함께 가져오는 것으로 이해할 수 있습니다.</p><p>주 메모리 등에서 캐시 라인을 가져와 캐시에 저장할 때 캐시 라인의 데이터를 식별하기 위한 태그 비트와 캐시 라인의 유효성을 검증하기 위한 유효 비트를 포함하여 하나의 캐시 엔트리가 완성됩니다.</p><p>그렇다면 캐시 엔트리는 캐시 메모리 공간 중 어디에 배치되어야 할까요? <code class="language-plaintext highlighter-rouge">8-way set associative</code>가 바로 그 내용을 담고 있습니다.</p><h2 id="캐시-배치-정책">캐시 배치 정책</h2><p><img data-proofer-ignore data-src="/assets/img/cs_1/cachefill.png" alt="cachefill" /></p><p>(출처: By Hellisp - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=851638)</p><p><code class="language-plaintext highlighter-rouge">Direct Mapped Cache</code> 방식에서는 캐시 메모리의 각 주소마다 저장될 메인 메모리의 주소가 정해져 있습니다. 캐시 메모리의 크기보다 메인 메모리의 크기가 훨씬 크기 때문에, 하나의 캐시 메모리 주소에 할당된 메인 메모리 주소가 많을 것입니다. 하지만 하나의 캐시 메모리 주소에 들어갈 수 있는 데이터는 하나의 메인 메모리 주소에 해당하는 데이터만 가능하기 때문에 같은 메모리 주소에 해당하는 메인 메모리의 주소를 여러 개 호출할 경우 바로 캐시 미스가 발생한다는 단점이 있습니다.</p><p>이 방법은 이상적인 경우 겹치는 주소가 하나도 없이 모든 캐시 메모리 공간에 배치되지만, 최악의 경우에는 하나의 캐시 메모리 주소에 서로 다른 메인 메모리 주소들이 계속 갱신되어 계속 캐시 미스가 발생할 수 있을 것입니다. 이렇게 캐시 미스가 발생할 확률이 꽤 높기 때문에 현재 쓰이는 방식은 아닙니다.</p><p>다음으로 <code class="language-plaintext highlighter-rouge">Fully Associative Cache</code> 방식이 있습니다. 이 방식은 비어있는 캐시 메모리 주소가 있으면 바로 저장합니다. 저장할 때도 쉬워보이고, 캐시 미스가 발생할 확률도 위의 <code class="language-plaintext highlighter-rouge">Direct Mapped Cache</code> 방식에 비하면 매우 적어보입니다. 하지만 캐시 메모리에서 필요한 데이터를 찾기 위해서는 일일히 검색해야 하기 때문에 시간이 오래 걸릴 것입니다. 따라서 이 방법도 거의 쓰이지 않습니다.</p><p>그렇다면 이 두 방식을 적절히 섞는 것은 어떨까요? <code class="language-plaintext highlighter-rouge">Set Associative Cache</code> 방식은 <code class="language-plaintext highlighter-rouge">Direct Mapped Cache</code> 처럼 메인 메모리 주소에 해당하는 캐시 메모리 주소를 두되, 그 주소에 들어갈 수 있는 메인 메모리 주소를 하나가 아니라 여러 개를 두고 그 중 비어 있는 곳에 <code class="language-plaintext highlighter-rouge">Fully Associative Cache</code> 처럼 저장하는 방식입니다.</p><p><code class="language-plaintext highlighter-rouge">8-way set associative</code>는 특정 주소마다 8개의 캐시 엔트리를 저장하는 방식이라는 의미입니다.</p><h2 id="캐시-교체-정책">캐시 교체 정책</h2><p>캐시 메모리의 공간은 한정되어 있고 메인 메모리에 비하면 매우 작은 크기이기 때문에 빠른 시간에 모든 공간에 데이터가 차게 될 것입니다. 예를 들어 위에서 <code class="language-plaintext highlighter-rouge">8-way set associative</code>의 경우 8개의 캐시 엔트리를 모두 채운 이후에 새로운 데이터를 캐시에 저장하고 싶다면 기존의 데이터를 새 데이터로 교체해야 하는데, 어떤 데이터를 교체할 것인지에 대한 수많은 정책들이 있습니다.</p><p>그 중에서 많이 쓰이는 방법은 <code class="language-plaintext highlighter-rouge">LRU (Least Recently Used)</code>, 또는 이에 기반하여 변형된 정책입니다. 주어진 공간이 모두 채워졌을 경우, 가장 이전에 사용된 데이터를 교체하는 방식입니다. 시간 지역성을 고려해보면 최근에 쓰였던 데이터는 다시 쓰일 확률이 높기 때문에 가장 이전에 쓰인 데이터를 교체하는 것으로 이해할 수 있습니다.</p><p>이 방식을 고수준 프로그래밍 언어로 구현한다면 <code class="language-plaintext highlighter-rouge">Doubly Linked List</code>와 <code class="language-plaintext highlighter-rouge">HashMap</code>을 이용하거나, Java와 같은 언어에서는 <code class="language-plaintext highlighter-rouge">LinkedHashMap</code>으로 구현할 수 있을 것입니다.</p><h1 id="smp">SMP</h1><p>SMP(Symmetric Multi-Processor, 대칭형 다중 프로세서)</p><h2 id="고려해야-할-문제점들">고려해야 할 문제점들</h2><p>비동기 프로그래밍에서 고려해야 할 문제점들 중에서 위의 내용들과 관련된, 프로세서와 메모리 단계에서 생각해야 할 문제점들이 있습니다. 프로그래머는 아래의 문제점들을 고려하면서 코드를 작성해야 합니다.</p><h3 id="비순차적-명령어-처리">비순차적 명령어 처리</h3><p>우선 프로세서가 들어오는 명령들을 순서대로 실행하지 않는 것이 있습니다. 예를 들어 여러 명령어가 프로세서에 들어 왔을 때 특정 명령어에서 로드한 메모리의 캐시 미스가 발생한다면 다시 데이터를 찾아 교체하는 시간이 필요할 것입니다. 그 동안 프로세서가 아무런 일을 하지 않고 기다리는 대신에, 기다리는 데이터와 관련 없는 다른 명령어가 그 이후에 있다면 그 명령어를 먼저 처리합니다. 또한 멀티스레드가 아니더라도 동시에 처리할 수 있는 명령어들은 동시에 먼저 처리하는 등의 방법으로 프로세서의 효율을 높입니다. 이를 <strong>비순차적 명령어 처리</strong>라고 합니다.</p><p>명령을 처리할 수 있는 코어가 하나인 프로세서이거나, 싱글 스레드로 작성된 프로그램이라면 위와 같이 비순차적으로 명령어를 처리해도 프로그래머 입장에서는 아무런 문제를 느낄 수 없습니다. 그 이유는 명령어 주소를 계산하여 그 주소에서 명령어를 가져오는 인출 단계와 명령어 완료 단계는 순차적으로 진행되기 때문에 결과적으로 작성된 코드가 순서상으로 변화되지 않았기 때문입니다.</p><p>하지만 프로세서의 코어가 여러 개이고, 멀티 스레드로 작성된 프로그램이라면 경우가 복잡해집니다. 예를 들어 L3 캐시 또는 메인 메모리에서 데이터를 인출하여 레지스터의 큐에 값을 저장한 동안 다른 코어가 같은 메모리 주소의 데이터를 변경시켰을 수도 있습니다. 하나의 메모리에 접근하고 변경할 수 있는 코어가 여러 개이기 때문에 발생하는 현상인 것입니다. 또한 모바일 프로세서는 대부분 x86이 아닌 ARM인데 저장 명령의 순서가 유지되지 않고, 모든 코어에 저장 명령이 동시에 도달하지 않을 수도 있습니다. 또한 이렇게 순서가 바뀌는 것은 프로세서 뿐만이 아니라 성능 향상을 위해 컴파일러에 의해서도 발생할 수 있습니다.</p><h3 id="데이터-경합">데이터 경합</h3><p>여러 스레드에서 같은 데이터에 동시에 접근하고, 데이터를 수정할 때 데이터 경합이 발생합니다.</p><p>한 스레드에서 <code class="language-plaintext highlighter-rouge">A = 5</code> 로 값을 할당하고, 다른 스레드에서 이 값을 읽는다고 할 때, 어떤 스레드가 먼저 실행될지 알 수 없기 때문에 A의 값이 어떻게 관찰될지 보장할 수 없습니다.</p><p>이 문제를 해결하기 위해서는 특정 변수에 대해 여러 스레드가 동시에 접근하는 것을 막거나 데이터의 원자성을 보장해야 하며, 많은 프로그래밍 언어에서 <code class="language-plaintext highlighter-rouge">Mutex</code>, <code class="language-plaintext highlighter-rouge">Volatile</code> 등의 다양한 방법으로 지원합니다.</p><h3 id="가짜-공유">가짜 공유</h3><p>데이터 경합을 막기 위해 락을 사용했다고 가정하면, 락이 걸린 캐시 주소에 해당하는 캐시 라인을 무효화 시킵니다. 위에서 캐시 라인별로 태그 비트가 달린다는 것을 알았기 때문에 왜 캐시 라인 전체가 무효화 되는지는 이해할 수 있을 것입니다.</p><p>그런데 여러 코어에서 동시에 같은 캐시 라인에 접근하려고 할 때 이렇게 락이 걸린다면, 안전하지만 성능 저하가 발생할 수 있을 것입니다. 무효화가 풀릴 때까지 다른 코어는 무효화가 풀리기를 기다려야 하기 때문입니다. 그렇다면 병렬적으로 작성된 코드도 실제로는 여러 스레드가 돌아가면서 작업하니 동시성은 만족하지만 병렬성은 달성하지 못하게 될 수도 있습니다.</p><h2 id="해결-방법들">해결 방법들</h2><p>이러한 문제들을 해결하기 위해 프로그래밍 언어에서 다양한 기법들을 라이브러리로 제공하고 있습니다. 이에 대한 내용은 이후의 포스트에서 별도로 정리하겠습니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a>, <a href='/categories/asynchronous/'>Asynchronous</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cs/" class="post-tag no-text-decoration" >CS</a> <a href="/tags/asynchronous/" class="post-tag no-text-decoration" >Asynchronous</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[CS] 비동기 프로그래밍 (1) - 캐시 메모리 - Devroid&url=https://crewdaniel.github.io/posts/cs_1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[CS] 비동기 프로그래밍 (1) - 캐시 메모리 - Devroid&u=https://crewdaniel.github.io/posts/cs_1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[CS] 비동기 프로그래밍 (1) - 캐시 메모리 - Devroid&url=https://crewdaniel.github.io/posts/cs_1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cs_3/">[CS] 비동기 프로그래밍 (3) - 동시성 프로그래밍</a><li><a href="/posts/cs_2/">[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크</a><li><a href="/posts/cs_1/">[CS] 비동기 프로그래밍 (1) - 캐시 메모리</a><li><a href="/posts/video_memo_10/">[Android] 동영상에 그림 그리기 (10) - 개선 리스트</a><li><a href="/posts/video_memo_8/">[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/opengl-es/">OpenGL ES</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/surface/">Surface</a> <a class="post-tag" href="/tags/egl/">EGL</a> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/surfacetexture/">SurfaceTexture</a> <a class="post-tag" href="/tags/async/">Async</a> <a class="post-tag" href="/tags/asynchronous/">Asynchronous</a> <a class="post-tag" href="/tags/boostcamp/">boostcamp</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cs_2/"><div class="card-body"> <span class="timeago small" >Jun 28<i class="unloaded">2022-06-28T03:30:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크</h3><div class="text-muted small"><p> Android의 스레드 사용 방법을 알기 전에, 리눅스의 스레드와 프로세스는 어떤 원리로 작동되는 것인지, 코어가 여러 개인 CPU에서 실제로 여러 프로세스나 스레드가 병렬적으로 작동하는지 알고 싶어 이 포스트로 정리하게 되었습니다. 운영체제라는 과목에서 일반적으로 배우는 프로세스, 스레드의 개념과 리눅스에서의 프로세스, 스레드는 유사하지만 약간의 차...</p></div></div></a></div><div class="card"> <a href="/posts/cs_3/"><div class="card-body"> <span class="timeago small" >Jul 8<i class="unloaded">2022-07-08T03:40:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[CS] 비동기 프로그래밍 (3) - 동시성 프로그래밍</h3><div class="text-muted small"><p> Android에서 애플리케이션을 실행하여 생성된 프로세스는 메인 스레드를 가지게 됩니다. 그리고 일반적으로 이 스레드는 UI 스레드로서, Android UI와 관련된 구성 요소(android.view, android.widget 패키지)가 작동하는 스레드입니다. 즉 이 스레드에서 UI의 상태를 변경하고, 사용자의 입력과 같은 이벤트를 받습니다. 따라서...</p></div></div></a></div><div class="card"> <a href="/posts/video_memo_10/"><div class="card-body"> <span class="timeago small" >Jan 24<i class="unloaded">2022-01-24T03:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (10) - 개선 리스트</h3><div class="text-muted small"><p> 이번 포스트에서는 boomerang 앱을 완성한 이후 수정, 개선한 부분들에 대해 작성하겠습니다. 이 포스트의 내용은 코드의 수정사항이 생기면 계속 추가하겠습니다. Vertex Buffer Object 지난 포스트에서 Vertex Buffer에 대해 작성하면서, java.nio 패키지의 ByteBuffer를 사용하는 방법(Client-side bu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/video_memo_10/" class="btn btn-outline-primary" prompt="Older"><p>[Android] 동영상에 그림 그리기 (10) - 개선 리스트</p></a> <a href="/posts/cs_2/" class="btn btn-outline-primary" prompt="Newer"><p>[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/CrewDaniel">Taehyun Park</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/opengl-es/">OpenGL ES</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/surface/">Surface</a> <a class="post-tag" href="/tags/egl/">EGL</a> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/surfacetexture/">SurfaceTexture</a> <a class="post-tag" href="/tags/async/">Async</a> <a class="post-tag" href="/tags/asynchronous/">Asynchronous</a> <a class="post-tag" href="/tags/boostcamp/">boostcamp</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
