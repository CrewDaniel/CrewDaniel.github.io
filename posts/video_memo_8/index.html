<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger" /><meta property="og:locale" content="ko" /><meta name="description" content="Android의 그래픽 버퍼 전달" /><meta property="og:description" content="Android의 그래픽 버퍼 전달" /><link rel="canonical" href="https://crewdaniel.github.io/posts/video_memo_8/" /><meta property="og:url" content="https://crewdaniel.github.io/posts/video_memo_8/" /><meta property="og:site_name" content="Devroid" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-12T02:12:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Android의 그래픽 버퍼 전달","url":"https://crewdaniel.github.io/posts/video_memo_8/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://crewdaniel.github.io/posts/video_memo_8/"},"headline":"[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger","dateModified":"2022-01-23T12:50:00+09:00","datePublished":"2022-01-12T02:12:00+09:00","@context":"https://schema.org"}</script><title>[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger | Devroid</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Devroid"><meta name="application-name" content="Devroid"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Devroid</a></div><div class="site-subtitle">안드로이드 개발 일지</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/CrewDaniel" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['alaskay','naver.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Taehyun Park </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 12, 2022, 2:12 AM +0900" >Jan 12<i class="unloaded">2022-01-12T02:12:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 23, 2022, 12:50 PM +0900" >Jan 23<i class="unloaded">2022-01-23T12:50:00+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1623 words">9 min read</span></div></div><div class="post-content"><p>이전 포스트들에서 <code class="language-plaintext highlighter-rouge">SurfaceTexture</code>, <code class="language-plaintext highlighter-rouge">Surface</code>, <code class="language-plaintext highlighter-rouge">MediaCodec</code> 등 미디어, 그래픽에 쓰이는 API들에 대해 다루었습니다.. 이러한 API들의 역할과 사용 방법에 대해서는 다루었지만, 작동 방식에 대해 조금 더 깊이 알아보고 싶어서 Google I/O ‘18의 <a href="https://www.youtube.com/watch?v=zdQRIYOST64">Drawn out: How Android renders</a> 라는 주제의 발표와 공식 문서의 내용들을 조합하여 정리하려 합니다.</p><p>이번 포스트에서 다루는 내용들은 개발자가 직접 조작이나 설정해야 하는 부분은 아니지만, 그래픽이 어떤 과정을 거쳐 화면에 표시되는지 이해하는 것에 도움이 될 것입니다.</p><p><img data-proofer-ignore data-src="/assets/img/video_memo_8/arch.png" alt="arch" /></p><p>(출처: <a href="https://source.android.com/devices/graphics">AOSP 그래픽</a>)</p><h1 id="bufferqueue">BufferQueue</h1><p><a href="https://source.android.com/devices/graphics/arch-bq-gralloc">BufferQueue</a>는 이름 그대로 (그래픽) 버퍼의 큐입니다. 버퍼의 수는 생성할 때 결정할 수 있습니다.</p><p>중요한 부분은 <strong><code class="language-plaintext highlighter-rouge">BufferQueue</code>는 두 개의 엔드포인트를 가지는데, 생산자와 소비자라고 합니다.</strong></p><p><img data-proofer-ignore data-src="/assets/img/video_memo_8/bufferqueue.png" alt="bufferqueue" /></p><p>(출처: <a href="https://source.android.com/devices/graphics">AOSP 그래픽</a>)</p><p>생산자는 <code class="language-plaintext highlighter-rouge">dequeueBuffer()</code>를 호출하여 <code class="language-plaintext highlighter-rouge">BufferQueue</code>에서 버퍼를 가져와 소유권을 얻습니다. 그 후 <strong>생산자</strong> 라는 이름에 맞게 내용을 채워넣을 수 있습니다. 그게 <code class="language-plaintext highlighter-rouge">Canvas</code>가 될 수도 있고, <code class="language-plaintext highlighter-rouge">OpenGL ES</code>가 될 수도 있으며, 픽셀 데이터를 직접 넣을 수도 있습니다.</p><p>생산자가 버퍼에 데이터를 모두 넣은 후에는, 다시 <code class="language-plaintext highlighter-rouge">BufferQueue</code>에 버퍼를 <code class="language-plaintext highlighter-rouge">queueBuffer()</code> 호출로 돌려줍니다. <code class="language-plaintext highlighter-rouge">SurfaceTexture</code> 클래스에서 OpenGL ES 렌더링이 끝난 후 <code class="language-plaintext highlighter-rouge">eglSwapBuffers()</code>를 호출하는 것도 이 <code class="language-plaintext highlighter-rouge">queueBuffer()</code> 과정에 해당합니다.</p><p>생산자의 역할은 끝났으니, 이제는 소비자 차례입니다. 소비자는 <code class="language-plaintext highlighter-rouge">acquireBuffer()</code>를 호출하여 <code class="language-plaintext highlighter-rouge">BufferQueue</code>에서 버퍼를 가져옵니다. 소비자는 가져온 버퍼로 원하는 작업을 수행하고(지난 포스트의 <code class="language-plaintext highlighter-rouge">MediaCodec</code>을 예로 들자면, 버퍼를 가져와서 MediaMuxer에 작성하였습니다.) <code class="language-plaintext highlighter-rouge">releaseBuffer()</code>로 다시 <code class="language-plaintext highlighter-rouge">BufferQueue</code>에 버퍼를 돌려줍니다.</p><p>이렇게 생산자와 소비자가 그래픽 버퍼를 <code class="language-plaintext highlighter-rouge">BufferQueue</code>를 통해 교환할 수 있기 때문에, 생산자와 소비자가 다른 성격의 API이더라도 그래픽 데이터를 전달할 수 있습니다. 따라서 이 앱에서 동영상을 재생하는 <code class="language-plaintext highlighter-rouge">MediaPlayer</code>로부터 OpenGL ES를 사용하는 <code class="language-plaintext highlighter-rouge">SurfaceTexture</code>에 프레임 단위로 동영상을 전달하는 것이 가능했던 것이죠.</p><p><code class="language-plaintext highlighter-rouge">BufferQueue</code>는 소비자에 해당하는 컴포넌트에서 생성하여, 나머지 하나의 엔드포인트에 해당하는 생산자에게 Surface를 넘겨주어 버퍼를 채우도록 합니다.</p><p>이전에 다뤘던 <code class="language-plaintext highlighter-rouge">Surface</code>는 <code class="language-plaintext highlighter-rouge">BufferQueue</code>의 생산자쪽 엔드포인트에 전달하여 그래픽 버퍼를 가져오기 위해 사용된 것입니다. 이 엔드포인트의 반대편, 즉 소비자는 주로 <code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>로, <code class="language-plaintext highlighter-rouge">Window</code>들의 그래픽 버퍼를 각각 BufferQueue로 모아 화면을 구성하는 역할을 합니다. 또한 제가 이전 포스트들에서 다룬 <code class="language-plaintext highlighter-rouge">SurfaceTexture</code>, <code class="language-plaintext highlighter-rouge">MediaCodec</code> API도 BufferQueue의 소비자 엔드포인트로 동작할 수 있습니다. <code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>를 소비자로 사용하게 되는 방법 중 하나는 <code class="language-plaintext highlighter-rouge">SurfaceView</code> API를 사용하는 것인데, 이는 다음 포스트에서 그림이 그려진 동영상을 재생하는 내용을 다루면서 작성하도록 하겠습니다.</p><h1 id="windowmanager">WindowManager</h1><p><code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>를 소비자로 하는 생산자는 <code class="language-plaintext highlighter-rouge">WindowManager</code> 가 있습니다.</p><p><img data-proofer-ignore data-src="/assets/img/video_memo_8/wisu.png" alt="windowmanager_surfaceflinger" /></p><p>SurfaceFlinger는 버퍼를 WindowManager로부터 받아 합성하여 새로운 버퍼를 디스플레이로 보냅니다.</p><p>WindowManager는 SurfaceFlinger가 Surface를 디스플레이에 합성하는데 사용하는 버퍼와 Window의 메타데이터를 SurfaceFlinger에 제공합니다.</p><p>우리가 Dialog, Toast, Activity와 같은 요소들을 만들 때, <code class="language-plaintext highlighter-rouge">Window</code> 객체가 생성됩니다. 그리고 SurfaceFlinger 쪽에도 Window에 해당하는 객체가 있는데, 이를 <code class="language-plaintext highlighter-rouge">Layer</code> 라고 합니다.</p><p><code class="language-plaintext highlighter-rouge">Layer</code>는 소비자의 역할로 <code class="language-plaintext highlighter-rouge">BufferQueue</code>를 생성하고 소유합니다. 그리고 <code class="language-plaintext highlighter-rouge">Surface</code>를 생산자에 해당하는 API들에게 전달하여 그래픽 버퍼들을 <code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>로 가져올 수 있게 됩니다.</p><h1 id="surfaceflinger">SurfaceFlinger</h1><p><img data-proofer-ignore data-src="/assets/img/video_memo_8/surfaceflinger.png" alt="surfaceflinger" /></p><p>(출처: <a href="https://source.android.com/devices/graphics">AOSP 그래픽</a>)</p><p><code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>는 이와 같이 <code class="language-plaintext highlighter-rouge">Layer</code>로부터 그래픽 버퍼를 가져옵니다. 이러한 Layer는 하나가 아닌 여러 개이고, 여러 소스로부터 그래픽 버퍼를 가져옵니다.</p><p>위 그림처럼 홈 화면이나 상태 표시줄, 시스템 UI 등은 각각의 <code class="language-plaintext highlighter-rouge">BufferQueue</code>를 통해 따로 그래픽 버퍼가 들어오게 됩니다.</p><p>생산자들은 그래픽 버퍼에 데이터를 계속 입력할 수 있지만, 소비자인 <code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>는 <code class="language-plaintext highlighter-rouge">BufferQueue</code>에서 그래픽 버퍼를 항상 가져오지 않습니다. 디스플레이 새로고침 사이에서만 버퍼를 가져옵니다. 이 새로고침 주기는 일반적으로 초당 60번, 즉 60fps로 동작하고 1프레임은 약 16ms동안 지속됩니다.</p><p>이렇게 새로운 버퍼를 탐색할 수 있도록 새로고침 신호를 주는 것을 <code class="language-plaintext highlighter-rouge">VSYNC</code>라고 합니다.</p><p><code class="language-plaintext highlighter-rouge">SurfaceFlinger</code>는 (60fps로 가정하고)16ms라는 짧은 시간 내에 <code class="language-plaintext highlighter-rouge">Layer</code> 목록에서 새로운 버퍼를 찾아 갱신하고, 새 버퍼가 없다면 기존의 버퍼를 계속 사용합니다.</p><p>그래픽 버퍼를 모두 수집한 후에는 하드웨어 컴포저(HWC)에 합성 유형을 묻고, SurfaceFlinger가 이에 해당하는 <code class="language-plaintext highlighter-rouge">Layer</code>를 합성한 후, 출력 버퍼를 하드웨어 컴포저에 전달합니다.</p><p>이 이후 구성은 하드웨어에 가까운 내용이기도 하고, 저의 현재 지식 수준으로는 이해하기 어려운 내용이 많아 여기까지 작성하겠습니다. 이후 내용은 하드웨어 추상 계층(HAL)을 통해 디스플레이 하드웨어 OEM에 의해 수행됩니다.</p><p>(참고자료: <a href="https://source.android.com/devices/graphics/surfaceflinger-windowmanager">SurfaceFlinger 및 WindowManager</a>)</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>Android</a>, <a href='/categories/boomerang/'>boomerang</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >Android</a> <a href="/tags/bufferqueue/" class="post-tag no-text-decoration" >BufferQueue</a> <a href="/tags/surface/" class="post-tag no-text-decoration" >Surface</a> <a href="/tags/surfaceflinger/" class="post-tag no-text-decoration" >SurfaceFlinger</a> <a href="/tags/windowmanager/" class="post-tag no-text-decoration" >WindowManager</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger - Devroid&url=https://crewdaniel.github.io/posts/video_memo_8/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger - Devroid&u=https://crewdaniel.github.io/posts/video_memo_8/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger - Devroid&url=https://crewdaniel.github.io/posts/video_memo_8/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cs_3/">[CS] 비동기 프로그래밍 (3) - 동시성 프로그래밍</a><li><a href="/posts/cs_2/">[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크</a><li><a href="/posts/cs_1/">[CS] 비동기 프로그래밍 (1) - 캐시 메모리</a><li><a href="/posts/video_memo_10/">[Android] 동영상에 그림 그리기 (10) - 개선 리스트</a><li><a href="/posts/video_memo_8/">[Android] 동영상에 그림 그리기 (8) - BufferQueue, WindowManager, SurfaceFlinger</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/opengl-es/">OpenGL ES</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/surface/">Surface</a> <a class="post-tag" href="/tags/egl/">EGL</a> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/surfacetexture/">SurfaceTexture</a> <a class="post-tag" href="/tags/async/">Async</a> <a class="post-tag" href="/tags/asynchronous/">Asynchronous</a> <a class="post-tag" href="/tags/boostcamp/">boostcamp</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/video_memo_9/"><div class="card-body"> <span class="timeago small" >Jan 13<i class="unloaded">2022-01-13T01:15:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (9) - SurfaceView로 화면 표시</h3><div class="text-muted small"><p> 지난 포스트에서는 MediaCodec에서 생성한 Surface에 비디오 버퍼를 전달하여 동영상을 저장하였습니다. 이번 포스트에서는 동영상을 사용자에게 표시하는 방법에 대해 작성하겠습니다. SurfaceView 사용자는 스스로가 그리고 있는 그림을 계속 확인하여야 하기 때문에, 화면에 표시될 것은 원본 동영상이 아닌 그림이 그려진 동영상의 각 이미지...</p></div></div></a></div><div class="card"> <a href="/posts/video_memo_2/"><div class="card-body"> <span class="timeago small" >Dec 21, 2021<i class="unloaded">2021-12-21T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (2) - Surface</h3><div class="text-muted small"><p> 동영상에 그림을 그려넣기 위해서 동영상을 각 프레임으로 나누어 그린 후 사용자에게 보여주고, 재생하기로 하였습니다(지난 포스트 참고). 그렇다면 어떻게 동영상을 프레임으로 나누어 그릴 수 있을까요? SurfaceTexture는 이미지 스트림에서 프레임을 캡처하여 OpenGL ES의 Texture로 저장합니다. 이미지 스트림에 대한 설명은 AOSP ...</p></div></div></a></div><div class="card"> <a href="/posts/video_memo_4/"><div class="card-body"> <span class="timeago small" >Dec 31, 2021<i class="unloaded">2021-12-31T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Android] 동영상에 그림 그리기 (4) - OpenGL ES의 Texture</h3><div class="text-muted small"><p> 이제 그림을 그릴 시간입니다. Android에서 OpenGL ES 렌더링 과정, 특히 SurfaceTexture를 사용하여 이미지를 텍스처로 사용하는 과정에 대해 정리하겠습니다. SurfaceTexture Texture 초기화 지난 글에서 onFrameAvailableListener를 통해 새로운 이미지 프레임을 받은 것을 알 수 있다고 하였습니...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/video_memo_7/" class="btn btn-outline-primary" prompt="Older"><p>[Android] 동영상에 그림 그리기 (7) - MediaCodec으로 인코딩</p></a> <a href="/posts/video_memo_9/" class="btn btn-outline-primary" prompt="Newer"><p>[Android] 동영상에 그림 그리기 (9) - SurfaceView로 화면 표시</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/CrewDaniel">Taehyun Park</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/opengl-es/">OpenGL ES</a> <a class="post-tag" href="/tags/cs/">CS</a> <a class="post-tag" href="/tags/surface/">Surface</a> <a class="post-tag" href="/tags/egl/">EGL</a> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/surfacetexture/">SurfaceTexture</a> <a class="post-tag" href="/tags/async/">Async</a> <a class="post-tag" href="/tags/asynchronous/">Asynchronous</a> <a class="post-tag" href="/tags/boostcamp/">boostcamp</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
