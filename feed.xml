<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://crewdaniel.github.io/</id><title>Devroid</title><subtitle>Android Dev Blog</subtitle> <updated>2022-07-08T03:44:01+09:00</updated> <author> <name>Taehyun Park</name> <uri>https://crewdaniel.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://crewdaniel.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://crewdaniel.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Taehyun Park </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[CS] 비동기 프로그래밍 (3) - 동시성 프로그래밍</title><link href="https://crewdaniel.github.io/posts/cs_3/" rel="alternate" type="text/html" title="[CS] 비동기 프로그래밍 (3) - 동시성 프로그래밍" /><published>2022-07-08T03:40:00+09:00</published> <updated>2022-07-08T03:40:00+09:00</updated> <id>https://crewdaniel.github.io/posts/cs_3/</id> <content src="https://crewdaniel.github.io/posts/cs_3/" /> <author> <name>Taehyun Park</name> </author> <category term="CS" /> <category term="Asynchronous" /> <summary> Android에서 애플리케이션을 실행하여 생성된 프로세스는 메인 스레드를 가지게 됩니다. 그리고 일반적으로 이 스레드는 UI 스레드로서, Android UI와 관련된 구성 요소(android.view, android.widget 패키지)가 작동하는 스레드입니다. 즉 이 스레드에서 UI의 상태를 변경하고, 사용자의 입력과 같은 이벤트를 받습니다. 따라서 이 스레드가 Blocking; 대기 상태에 놓이면 UI가 업데이트 되지 않으며, 이벤트에 반응할 수 없기 때문에 사용자는 앱을 사용할 수 없게 되며 에러가 발생한 것으로 여기게 됩니다. UI 스레드가 5초 이상 차단되면 ANR(Application Not Responding) 대화상자가 표시됩니다. 따라서 Android 애플리케이션 개발에 있어서 네트워... </summary> </entry> <entry><title>[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크</title><link href="https://crewdaniel.github.io/posts/cs_2/" rel="alternate" type="text/html" title="[CS] 비동기 프로그래밍 (2) - 리눅스의 프로세스, 스레드, 태스크" /><published>2022-06-28T03:30:00+09:00</published> <updated>2022-06-28T03:30:00+09:00</updated> <id>https://crewdaniel.github.io/posts/cs_2/</id> <content src="https://crewdaniel.github.io/posts/cs_2/" /> <author> <name>Taehyun Park</name> </author> <category term="CS" /> <category term="Asynchronous" /> <summary> Android의 스레드 사용 방법을 알기 전에, 리눅스의 스레드와 프로세스는 어떤 원리로 작동되는 것인지, 코어가 여러 개인 CPU에서 실제로 여러 프로세스나 스레드가 병렬적으로 작동하는지 알고 싶어 이 포스트로 정리하게 되었습니다. 운영체제라는 과목에서 일반적으로 배우는 프로세스, 스레드의 개념과 리눅스에서의 프로세스, 스레드는 유사하지만 약간의 차이가 있습니다. 이 차이를 몰랐을 때 저는 왜 안드로이드 앱 개발에서 스레드 대신에 Coroutine 사용을 권장하는 것인지 의문이 있었습니다. 그냥 더 가볍고, 스레드를 적게 생성한다는 설명만으로는 이해하기 어려운 부분이 있습니다. 왜냐하면 운영체제 과목에서는 스레드를 일종의 경량 프로세스이며, 프로세스의 수행 흐름을 여러 개로 나눌 수 있다고 배웠는데 ... </summary> </entry> <entry><title>[CS] 비동기 프로그래밍 (1) - 캐시 메모리</title><link href="https://crewdaniel.github.io/posts/cs_1/" rel="alternate" type="text/html" title="[CS] 비동기 프로그래밍 (1) - 캐시 메모리" /><published>2022-02-19T23:00:00+09:00</published> <updated>2022-02-26T01:00:00+09:00</updated> <id>https://crewdaniel.github.io/posts/cs_1/</id> <content src="https://crewdaniel.github.io/posts/cs_1/" /> <author> <name>Taehyun Park</name> </author> <category term="CS" /> <category term="Asynchronous" /> <summary> 비동기 프로그래밍에 대해 공부를 하다보니 굉장히 멀리 오게 되었고, 그래서 하나씩 정리를 하려고 합니다. bottom-up 방식으로 작성하여 첫 게시글인 캐시 메모리에서부터 가장 고단위인 코루틴까지 작성할 예정입니다. 캐시 메모리 캐시 메모리에 대해 모든 내용을 작성하기 보다는, 비동기 프로그래밍을 이해하는 것에 필요한 내용 위주로 정리하였습니다. 데이터 지역성 캐시 메모리는 데이터의 지역성을 이용하여 처리 속도를 높입니다. 캐시 메모리가 가져오는 데이터는 프로세서에서 자주 쓰이는 데이터여야 합니다. 한 번만 쓰고 다시 다른 데이터를 불러온다면, 그냥 저장소에서 바로 가져오는 것이 여러 중간단계를 거치는 것보다 더 빠를 것입니다. 캐시 메모리에 쓰이는 데이터는 프로세서에서 자주 접근하는 데이... </summary> </entry> <entry><title>[Android] 동영상에 그림 그리기 (10) - 개선 리스트</title><link href="https://crewdaniel.github.io/posts/video_memo_10/" rel="alternate" type="text/html" title="[Android] 동영상에 그림 그리기 (10) - 개선 리스트" /><published>2022-01-24T03:00:00+09:00</published> <updated>2022-01-24T03:00:00+09:00</updated> <id>https://crewdaniel.github.io/posts/video_memo_10/</id> <content src="https://crewdaniel.github.io/posts/video_memo_10/" /> <author> <name>Taehyun Park</name> </author> <category term="Android" /> <category term="boomerang" /> <summary> 이번 포스트에서는 boomerang 앱을 완성한 이후 수정, 개선한 부분들에 대해 작성하겠습니다. 이 포스트의 내용은 코드의 수정사항이 생기면 계속 추가하겠습니다. Vertex Buffer Object 지난 포스트에서 Vertex Buffer에 대해 작성하면서, java.nio 패키지의 ByteBuffer를 사용하는 방법(Client-side buffer)과, OpenGL ES에서 버퍼를 생성하는 두 가지 방법이 있다고 하였습니다. OpenGL ES의 버퍼를 사용하는 방식으로 수정해보았습니다. val vertexBuffer = IntArray(1) GLES20.glGenBuffers(1, vertexBuffer, 0) 우선 버퍼를 생성해야 합니다. IntArray를 생성하는 것은 빈 배열을 생... </summary> </entry> <entry><title>[Android] 동영상에 그림 그리기 (9) - SurfaceView로 화면 표시</title><link href="https://crewdaniel.github.io/posts/video_memo_9/" rel="alternate" type="text/html" title="[Android] 동영상에 그림 그리기 (9) - SurfaceView로 화면 표시" /><published>2022-01-13T01:15:00+09:00</published> <updated>2022-01-19T02:30:00+09:00</updated> <id>https://crewdaniel.github.io/posts/video_memo_9/</id> <content src="https://crewdaniel.github.io/posts/video_memo_9/" /> <author> <name>Taehyun Park</name> </author> <category term="Android" /> <category term="boomerang" /> <summary> 지난 포스트에서는 MediaCodec에서 생성한 Surface에 비디오 버퍼를 전달하여 동영상을 저장하였습니다. 이번 포스트에서는 동영상을 사용자에게 표시하는 방법에 대해 작성하겠습니다. SurfaceView 사용자는 스스로가 그리고 있는 그림을 계속 확인하여야 하기 때문에, 화면에 표시될 것은 원본 동영상이 아닌 그림이 그려진 동영상의 각 이미지 프레임입니다. 지난 포스트에서 그림이 그려진 그래픽 버퍼를 어떻게 SurfaceView의 Surface로 전달하는지에 대해서 작성하였습니다. SurfaceView를 이름과 연관지어 설명하자면 Surface+View로, 뷰 계층구조 내에 추가적인 Surface를 생성하고자 할 때 사용할 수 있습니다. 뷰 계층구조 내에 추가적인 Surface가 필요할 때... </summary> </entry> </feed>
